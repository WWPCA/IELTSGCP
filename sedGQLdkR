import os
import json
import uuid
import logging
import time
from functools import wraps
from datetime import datetime, timedelta

from flask import render_template, url_for, flash, redirect, request, jsonify, session, abort
from flask_login import login_user, current_user, logout_user, login_required
from werkzeug.security import generate_password_hash, check_password_hash

from app import app, db
from models import (User, TestStructure, PracticeTest, UserTestAttempt, 
                   SpeakingPrompt, SpeakingResponse, PaymentMethod, Translation, CountryPricing,
                   CompletePracticeTest, CompleteTestProgress)

# Add context processor to provide cache_buster to all templates
@app.context_processor
def inject_cache_buster():
    """Add cache_buster variable to all templates to prevent browser caching"""
    return dict(cache_buster=int(time.time()))

from utils import get_user_region, get_translation, compress_audio
from aws_services import (transcribe_audio, generate_polly_speech, analyze_speaking_response, 
                      analyze_pronunciation, generate_pronunciation_exercises)
from payment_services import create_stripe_checkout, verify_payment
from geoip_services import get_country_from_ip, get_pricing_for_country

# Helper functions
def subscription_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or not current_user.is_subscribed():
            flash('This feature requires a subscription. Please subscribe to continue.', 'warning')
            return redirect(url_for('subscribe'))
        return f(*args, **kwargs)
    return decorated_function

# Streak tracking removed as requested

# Home route
@app.route('/')
def index():
    return render_template('index.html', title='IELTS AI Prep')

# Authentication routes
@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('index'))

    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        remember = 'remember' in request.form
        
        if not email or not password:
            flash('Please provide both email and password.', 'danger')
            return render_template('login.html', title='Login')
            
        user = User.query.filter_by(email=email).first()
        
        if user and check_password_hash(user.password_hash, password):
            login_user(user, remember=remember)
            next_page = request.args.get('next')
            flash('Login successful!', 'success')
            return redirect(next_page if next_page else url_for('index'))
        else:
            flash('Invalid email or password.', 'danger')
            
    return render_template('login.html', title='Login')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    
    class RegistrationForm:
        # Simple form class to enable CSRF protection
        def __init__(self):
            pass

    form = RegistrationForm()
    
    if request.method == 'POST':
        username = request.form.get('username')
        email = request.form.get('email')
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        region = request.form.get('region', get_user_region())
        
        if password != confirm_password:
            flash('Passwords do not match!', 'danger')
            return render_template('register.html', title='Register', form=form)
        
        existing_user = User.query.filter((User.username == username) | (User.email == email)).first()
        if existing_user:
            flash('Username or email already exists!', 'danger')
            return render_template('register.html', title='Register', form=form)
        
        test_preference = request.form.get('test_preference', 'academic')
        
        new_user = User(
            username=username,
            email=email,
            region=region,
            test_preference=test_preference
        )
        new_user.set_password(password)
        
        db.session.add(new_user)
        db.session.commit()
        
        flash('Registration successful! You can now log in.', 'success')
        return redirect(url_for('login'))
    
    return render_template('register.html', title='Register', form=form)

@app.route('/logout')
def logout():
    logout_user()
    flash('You have been logged out.', 'info')
    return redirect(url_for('index'))

@app.route('/profile')
@login_required
def profile():
    # Profile page is now simplified, no streak data needed
    return render_template('profile.html', title='My Profile')

# Test Structure Routes
@app.route('/test-structure')
def test_structure():
    return render_template('test_structure/index.html', title='IELTS Test Structure')

@app.route('/test-structure/<test_type>')
def test_structure_detail(test_type):
    test_info = TestStructure.query.filter_by(test_type=test_type).first_or_404()
    return render_template(f'test_structure/{test_type}.html', 
                          title=f'IELTS {test_type.replace("_", " ").title()}',
                          test_info=test_info)

@app.route('/test-day')
@login_required
def test_day():
    # Check if user has purchased a value pack (4 tests package)
    if not current_user.is_authenticated:
        flash('Please log in to access the Test Day Guide.', 'warning')
        return redirect(url_for('login'))
    
    # Check if user has the 4-test value pack
    has_value_pack = False
    test_history = current_user.test_history
    
    for entry in test_history:
        # Check for test purchases with the "pack" package (4 tests)
        if 'test_purchase' in entry and entry['test_purchase'].get('test_package') == 'pack':
            # Check if the purchase is still valid (not expired)
            purchase_expiry = datetime.fromisoformat(entry['test_purchase'].get('expiry_date'))
            if purchase_expiry > datetime.utcnow():
                has_value_pack = True
                break
    
    if not has_value_pack:
        flash('The Test Day Guide is only available with the Value Pack (4 tests) subscription.', 'warning')
        return redirect(url_for('subscribe'))
    
    return render_template('test_day.html', title='IELTS Test Day Preparation')

# Practice Test Routes
@app.route('/practice')
def practice_index():
    test_types = ['listening', 'reading', 'writing']
    sample_tests = {}
    
    for test_type in test_types:
        sample_tests[test_type] = PracticeTest.query.filter_by(test_type=test_type).first()
    
    # Get complete tests based on user's test preference
    complete_tests = []
    test_progress = {}
    
    if current_user.is_authenticated:
        # Filter tests by user's test preference
        user_test_preference = current_user.test_preference
        
        # Get tests (free ones and those matching user's subscription level)
        # Use subquery to get only the latest version of each test number (to avoid duplicates)
        from sqlalchemy import func
        
        # For each test number, get the maximum ID (latest version)
        if current_user.is_subscribed():
            # First get the latest ID for each test number - show academic tests for premium users
            subquery = db.session.query(
                CompletePracticeTest.test_number,
                func.max(CompletePracticeTest.id).label('max_id')
            ).filter(
                CompletePracticeTest.ielts_test_type == 'academic'  # Always show academic tests 
            ).group_by(CompletePracticeTest.test_number).subquery()
            
            # Then join to get the complete test records
            complete_tests = CompletePracticeTest.query.join(
                subquery,
                db.and_(
                    CompletePracticeTest.id == subquery.c.max_id,
                    CompletePracticeTest.test_number == subquery.c.test_number
                )
            ).order_by(CompletePracticeTest.test_number).all()
        else:
            # For non-subscribers, only show free tests (also avoid duplicates)
            subquery = db.session.query(
                CompletePracticeTest.test_number,
                func.max(CompletePracticeTest.id).label('max_id')
            ).filter(
                CompletePracticeTest.ielts_test_type == user_test_preference,
                CompletePracticeTest.is_free == True
            ).group_by(CompletePracticeTest.test_number).subquery()
            
            complete_tests = CompletePracticeTest.query.join(
                subquery,
                db.and_(
                    CompletePracticeTest.id == subquery.c.max_id,
                    CompletePracticeTest.test_number == subquery.c.test_number
                )
            ).order_by(CompletePracticeTest.test_number).all()
            
        # Get progress for each test
        if complete_tests:
            user_progress = CompleteTestProgress.query.filter_by(user_id=current_user.id).all()
            for progress in user_progress:
                # Calculate percentage complete
                if progress.section_progress:
                    num_sections = len(progress.section_progress)
                    num_completed = sum(1 for section in progress.section_progress.values() 
                                      if section.get('completed', False))
                    progress_percent = int((num_completed / max(1, num_sections)) * 100)
                    
                    test_progress[progress.complete_test_id] = {
                        'progress_percent': progress_percent,
                        'is_completed': progress.is_test_completed(),
                        'score': progress.get_overall_score() if progress.is_test_completed() else None,
                        'status': 'Completed' if progress.is_test_completed() 
                                else f'{num_completed} of {num_sections} sections completed'
                    }
    else:
        # For anonymous users, just show a sample of free tests (avoiding duplicates)
        from sqlalchemy import func
        
        # First get the latest ID for each test number
        subquery = db.session.query(
            CompletePracticeTest.test_number,
            CompletePracticeTest.ielts_test_type,
            func.max(CompletePracticeTest.id).label('max_id')
        ).filter(
            CompletePracticeTest.is_free == True
        ).group_by(CompletePracticeTest.test_number, CompletePracticeTest.ielts_test_type).subquery()
        
        # Then get the complete test records using those IDs
        complete_tests = CompletePracticeTest.query.join(
            subquery,
            db.and_(
                CompletePracticeTest.id == subquery.c.max_id,
                CompletePracticeTest.test_number == subquery.c.test_number,
                CompletePracticeTest.ielts_test_type == subquery.c.ielts_test_type
            )
        ).limit(4).all()
    
    return render_template('practice/index.html', title='Practice Tests', 
                          sample_tests=sample_tests,
                          complete_tests=complete_tests,
                          test_progress=test_progress)

@app.route('/practice/<test_type>')
@login_required
def practice_test_list(test_type):
    if test_type not in ['listening', 'reading', 'writing']:
        abort(404)
        
    # Get all tests of this type, but filter to just show ones with complete questions and answers
    tests = PracticeTest.query.filter_by(test_type=test_type).all()
    
    # If we have premium users, show all tests
    if not current_user.is_subscribed():
        # For non-subscribers, only show the first test
        tests = tests[:1] if tests else []
    
    # Get a list of test IDs the user has already completed
    completed_test_ids = [test['test_id'] for test in current_user.completed_tests 
                         if test['test_type'] == test_type]
    
    return render_template(f'practice/{test_type}.html', 
                          title=f'IELTS {test_type.capitalize()} Practice',
                          tests=tests,
                          completed_test_ids=completed_test_ids)

@app.route('/practice/<test_type>/<int:test_id>')
@login_required
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test
def take_practice_test

def take_practice_test(test_type, test_id):
    if test_type not in ['listening', 'reading', 'writing']:
        abort(404)
    
    test = PracticeTest.query.get_or_404(test_id)
    
    # All tests require subscription
    if not current_user.is_subscribed():
        flash('This test requires a subscription. Please subscribe to access all practice tests.', 'warning')
        return redirect(url_for('subscribe'))
    
    # Check if user has already taken this test during current subscription period
    if current_user.has_taken_test(test_id, test_type):
        flash('You have already taken this test during your current subscription period. Each test can only be taken once per subscription.', 'warning')
        return redirect(url_for('practice_test_list', test_type=test_type))
    
    # Handle new question format for listening tests
    if test_type == 'listening':
        # Convert questions from JSON string to Python list/dict
        import json
        if isinstance(test.questions, str):
            test.questions = json.loads(test.questions)
    
    return render_template(f'practice/{test_type}.html', 
                          title=f'IELTS {test_type.capitalize()} Practice',
                          test=test,
                          taking_test=True)

# Complete Test Routes
@app.route('/practice/complete-test/<int:test_id>/start')
@login_required
def submit_test
def take_complete_test_section
def continue_complete_test

def start_complete_test(test_id):
    """Start a new complete IELTS practice test"""
    complete_test = CompletePracticeTest.query.get_or_404(test_id)
    
    # Check if user has access to this test
    if not current_user.is_subscribed():
        flash('This test requires a subscription. Please subscribe to access all practice tests.', 'warning')
        return redirect(url_for('subscribe'))
    
    # We now allow users to access all test types regardless of preference
    # Keep a comment explaining the change for future reference
    # Previously, we were restricting users to only take tests that matched their preference
    
    # Check if user already has an in-progress attempt
    existing_progress = CompleteTestProgress.query.filter_by(
        user_id=current_user.id,
        complete_test_id=test_id
    ).first()
    
    if existing_progress:
        if existing_progress.is_test_completed():
            flash('You have already completed this test.', 'info')
            return redirect(url_for('practice_index'))
        
        # Continue existing progress
        return redirect(url_for('continue_complete_test', test_id=test_id))
    
    # Start a new test progress
    progress = CompleteTestProgress(
        user_id=current_user.id,
        complete_test_id=test_id,
        start_date=datetime.utcnow()
    )
    
    # All IELTS tests start with the listening section
    progress.current_section = 'listening'
    
    db.session.add(progress)
    db.session.commit()
    
    # Redirect to the first section
    return redirect(url_for('take_complete_test_section', 
                            test_id=test_id, 
                            section=progress.current_section))

@app.route('/practice/complete-test/<int:test_id>/continue')
@login_required
def submit_test
def take_complete_test_section

def continue_complete_test(test_id):
    """Continue an in-progress complete test"""
    # Get user's progress for this test
    progress = CompleteTestProgress.query.filter_by(
        user_id=current_user.id,
        complete_test_id=test_id
    ).first_or_404()
    
    # If the test is already completed, show results
    if progress.is_test_completed():
        return redirect(url_for('complete_test_results', test_id=test_id))
    
    # Get the next section to complete
    next_section = progress.get_next_section()
    if not next_section:
        # Test is completed
        progress.completed_date = datetime.utcnow()
        db.session.commit()
        return redirect(url_for('complete_test_results', test_id=test_id))
    
    # Update current section
    progress.current_section = next_section
    db.session.commit()
    
    # Redirect to that section
    return redirect(url_for('take_complete_test_section', 
                            test_id=test_id, 
                            section=next_section))

@app.route('/practice/complete-test/<int:test_id>/<section>')
@login_required
def submit_test

def take_complete_test_section(test_id, section):
    """Take a specific section of a complete test"""
    if section not in ['listening', 'reading', 'writing', 'speaking']:
        abort(404)
    
    # Verify user has an in-progress test
    progress = CompleteTestProgress.query.filter_by(
        user_id=current_user.id,
        complete_test_id=test_id
    ).first_or_404()
    
    # Ensure the user is on the correct section
    if progress.current_section != section:
        flash(f'Please complete the {progress.current_section} section first.', 'warning')
        return redirect(url_for('continue_complete_test', test_id=test_id))
    
    complete_test = CompletePracticeTest.query.get_or_404(test_id)
    
    # Get the section test
    section_test = PracticeTest.query.filter_by(
        complete_test_id=test_id,
        test_type=section,
        ielts_test_type=complete_test.ielts_test_type
    ).first_or_404()
    
    # Handle question format for different test types
    if section == 'listening':
        # Convert questions from JSON string to Python list/dict if not already parsed
        import json
        if isinstance(section_test.questions, str):
            section_test.questions = json.loads(section_test.questions)
    
    return render_template(f'practice/{section}.html', 
                          title=f'IELTS {section.capitalize()} Test',
                          test=section_test,
                          taking_test=True,
                          complete_test_id=test_id,
                          test_progress=progress)

@app.route('/practice/complete-test/<int:test_id>/results')
@login_required
def submit_test
def complete_test_results(test_id):
    """View results of a completed test"""
    # Get the user's progress for this test
    progress = CompleteTestProgress.query.filter_by(
        user_id=current_user.id,
        complete_test_id=test_id
    ).first_or_404()
    
    if not progress.is_test_completed():
        flash('Please complete all sections of the test first.', 'warning')
        return redirect(url_for('continue_complete_test', test_id=test_id))
    
    complete_test = CompletePracticeTest.query.get_or_404(test_id)
    
    # Get all attempts for this test
    section_attempts = []
    for section_type in ['listening', 'reading', 'writing', 'speaking']:
            
        section_test = PracticeTest.query.filter_by(
            complete_test_id=test_id,
            test_type=section_type
        ).first()
        
        if section_test:
            attempt = UserTestAttempt.query.filter_by(
                user_id=current_user.id,
                test_id=section_test.id,
                complete_test_progress_id=progress.id
            ).first()
            
            section_attempts.append({
                'section_type': section_type,
                'test': section_test,
                'attempt': attempt,
                'score': progress.section_progress.get(section_type, {}).get('score', 0) if progress.section_progress else 0
            })
    
    return render_template('practice/complete_test_results.html',
                          title='Test Results',
                          complete_test=complete_test,
                          progress=progress,
                          section_attempts=section_attempts,
                          overall_score=progress.get_overall_score())

@app.route('/api/submit-test', methods=['POST'])
@login_required

def submit_test():
    data = request.json
    test_id = data.get('test_id')
    user_answers = data.get('answers')
    complete_test_id = data.get('complete_test_id')  # May be None for individual section practice
    
    if not test_id or not user_answers:
        return jsonify({'error': 'Missing required data'}), 400
    
    test = PracticeTest.query.get_or_404(test_id)
    
    # Parse answers from JSON string
    import json
    correct_answers = json.loads(test.answers)
    
    # Calculate score
    score = 0
    total_questions = len(correct_answers)
    
    for q_id, user_answer in user_answers.items():
        if q_id in correct_answers and user_answer.lower() == correct_answers[q_id].lower():
            score += 1
    
    score_percentage = (score / total_questions) * 100 if total_questions > 0 else 0
    
    # Convert to band score for IELTS (0-9 scale)
    band_score = (score_percentage / 100) * 9
    
    # Get complete test progress if this is part of a complete test
    complete_test_progress = None
    if complete_test_id:
        complete_test_progress = CompleteTestProgress.query.filter_by(
            user_id=current_user.id,
            complete_test_id=complete_test_id
        ).first()
        
        if complete_test_progress:
            # Mark this section as completed
            complete_test_progress.mark_section_completed(test.test_type, band_score)
    
    # Save the attempt
    attempt = UserTestAttempt(
        user_id=current_user.id,
        test_id=test_id,
        complete_test_progress_id=complete_test_progress.id if complete_test_progress else None,
        user_answers=user_answers,
        score=score_percentage
    )
    
    db.session.add(attempt)
    
    # Update user's test history
    test_history = current_user.test_history
    test_history.append({
        'test_id': test_id,
        'test_type': test.test_type,
        'title': test.title,
        'date': datetime.utcnow().isoformat(),
        'score': score_percentage,
        'complete_test_id': complete_test_id
    })
    current_user.test_history = test_history
    
    # For individual section practice (not part of complete test)
    if not complete_test_id:
        # Mark this test as completed so it can't be retaken during current subscription period
        current_user.mark_test_completed(test_id, test.test_type)
    
    db.session.commit()
    
    response_data = {
        'score': score_percentage,
        'band_score': round(band_score, 1),
        'correct': score,
        'total': total_questions
    }
    
    # Check if complete test is now completed
    if complete_test_progress and complete_test_progress.is_test_completed():
        response_data['complete_test_finished'] = True
        response_data['results_url'] = url_for('complete_test_results', test_id=complete_test_id)
    elif complete_test_progress:
        response_data['next_section'] = complete_test_progress.get_next_section()
        response_data['next_section_url'] = url_for('continue_complete_test', test_id=complete_test_id)
        
    return jsonify(response_data)

# Speaking Assessment Routes
# Speaking routes removed as requested
# @app.route('/speaking')
# def speaking_index():
#     # Redirect to the practice test list page for complete tests
#     flash('Speaking assessments are now available as part of complete IELTS practice tests.', 'info')
#     return redirect(url_for('practice_index'))
# 
# @app.route('/speaking/<int:prompt_id>')
# @login_required
# def speaking_assessment(prompt_id):
#     # Redirect to the practice test list page for complete tests
#     flash('Speaking assessments are now available as part of complete IELTS practice tests.', 'info')
#     return redirect(url_for('practice_index'))

@app.route('/practice/submit-speaking/<int:test_id>', methods=['POST'])
@login_required

def submit_speaking_response(test_id):
    """Submit a speaking response for a complete test section"""
    audio_blob = request.form.get('audio_blob')
    complete_test_id = request.form.get('complete_test_id')
    
    if not audio_blob:
        flash('No audio recording was provided.', 'danger')
        if complete_test_id:
            return redirect(url_for('take_complete_test_section', 
                                   test_id=complete_test_id, 
                                   section='speaking'))
        return redirect(url_for('practice_index'))
    
    # Process the audio file from the blob data
    import base64
    audio_data = base64.b64decode(audio_blob.split(',')[1])
    
    # Save the audio file
    filename = f"user_{current_user.id}_test_{test_id}_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}.mp3"
    audio_path = os.path.join('static', 'uploads', 'audio', filename)
    os.makedirs(os.path.dirname(audio_path), exist_ok=True)
    
    with open(audio_path, 'wb') as f:
        f.write(audio_data)
    
    # Compress the audio
    compressed_path = compress_audio(audio_path)
    
    try:
        # Get the test
        test = PracticeTest.query.get_or_404(test_id)
        
        # Transcribe and analyze the response
        transcription = transcribe_audio(compressed_path)
        scores, feedback = analyze_speaking_response(transcription)
        
        # Generate audio feedback
        feedback_audio_filename = f"feedback_{os.path.basename(compressed_path)}"
        feedback_audio_path = os.path.join('static', 'uploads', 'feedback', feedback_audio_filename)
        os.makedirs(os.path.dirname(feedback_audio_path), exist_ok=True)
        
        polly_result = generate_polly_speech(feedback, feedback_audio_path)
        
        # Create a speaking response record
        response = SpeakingResponse(
            user_id=current_user.id,
            prompt_id=test_id,  # Using the test ID as the prompt ID
            audio_url=compressed_path.replace('static/', ''),
            transcription=transcription,
            scores=scores,
            feedback_audio_url=feedback_audio_path.replace('static/', '') if polly_result else None
        )
        
        db.session.add(response)
        
        # Create a test attempt record
        new_attempt = UserTestAttempt(
            user_id=current_user.id,
            test_id=test_id,
            user_answers={'transcription': transcription},
            score=scores.get('overall', 0) if isinstance(scores, dict) else 0,
            assessment=json.dumps({
                'transcription': transcription,
                'scores': scores,
                'feedback': feedback
            })
        )
        
        if complete_test_id:
            # Get the user's progress for this complete test