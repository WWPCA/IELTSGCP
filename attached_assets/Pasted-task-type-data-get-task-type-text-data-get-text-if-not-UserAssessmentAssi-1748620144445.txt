task_type = data.get('task_type')
        text = data.get('text')

        if not UserAssessmentAssignment.query.filter_by(
            user_id=current_user.id,
            assessment_type=product_id,
            status='active'
        ).first():
            return jsonify({'success': False, 'error': 'No active assessment available'}), 403

        if product_id in ['academic_writing', 'general_writing']:
            result = (
                assess_writing_task1(text, current_user.id)
                if task_type == 'task1'
                else assess_writing_task2(text, current_user.id)
            )
            if result.get('success'):
                # Mark assignment as used
                assignment = UserAssessmentAssignment.query.filter_by(
                    user_id=current_user.id,
                    assessment_type=product_id,
                    status='active'
                ).first()
                assignment.status = 'completed'
                db.session.commit()
            return jsonify(result)
        return jsonify({'success': False, 'error': 'Invalid product or task'}), 400
    except Exception as e:
        app.logger.error(f"Writing assessment error for user {current_user.id}: {e}")
        return jsonify({'success': False, 'error': 'Assessment failed'}), 500
ClearScore (AWS Sonic + AWS Nova Micro):
Context: Speaking assessments involve real-time conversation (AWS Sonic) and written feedback (AWS Nova Micro). The purchase process grants access, but the submission route is missing.
Recommendation: Add a route for speaking submissions:
python

Copy
@app.route('/api/submit-speaking', methods=['POST'])
@login_required
def submit_speaking():
    try:
        data = request.get_json()
        product_id = data.get('product_id')
        audio_data = data.get('audio_data')

        if not UserAssessmentAssignment.query.filter_by(
            user_id=current_user.id,
            assessment_type=product_id,
            status='active'
        ).first():
            return jsonify({'success': False, 'error': 'No active assessment available'}), 403

        if product_id in ['academic_speaking', 'general_speaking']:
            sonic_result = analyze_speaking_response(audio_data)
            if not sonic_result.get('success'):
                return jsonify(sonic_result), 500

            nova_result = aws_nova_micro_client.generate_feedback(
                analysis=sonic_result['analysis'],
                rubric='ielts_speaking'
            )
            if nova_result.get('success'):
                # Mark assignment as used
                assignment = UserAssessmentAssignment.query.filter_by(
                    user_id=current_user.id,
                    assessment_type=product_id,
                    status='active'
                ).first()
                assignment.status = 'completed'
                db.session.commit()
            return jsonify({
                'success': nova_result.get('success'),
                'score': sonic_result.get('score'),
                'feedback': nova_result.get('feedback')
            })
        return jsonify({'success': False, 'error': 'Invalid product'}), 400
    except Exception as e:
        app.logger.error(f"Speaking assessment error for user {current_user.id}: {e}")
        return jsonify({'success': False, 'error': 'Assessment failed'}), 500
AWS API Resilience:
Issue: AWS API calls (e.g., analyze_speaking_response, assess_writing_task1) may fail due to rate limits or network issues.
Recommendation: Use retry logic (as shown previously):
python

Copy
from botocore.exceptions import ClientError
def call_aws_api_with_retry(client, method, **kwargs):
    retries = 3
    for attempt in range(retries):
        try:
            return getattr(client, method)(**kwargs)
        except ClientError as e:
            if e.response['Error']['Code'] == 'ThrottlingException' and attempt < retries - 1:
                time.sleep(2 ** attempt)
                continue
            raise
Additional Recommendations
Centralized Configuration:
Move assessment_products and other constants (e.g., ASSESSMENT_ACCESS_DAYS) to a config.py file to avoid duplication and improve maintainability.
Logging:
Use structured logging for all payment and assessment actions:
python

Copy
import structlog
logger = structlog.get_logger()
logger.info("Payment processed", user_id=user.id, product_id=product_id)
Testing:
Add unit tests for routes and payment functions:
python

Copy
def test_profile(client, login_user):
    response = client.get('/profile')
    assert response.status_code == 200
    assert b'My Profile' in response.data

def test_product_checkout(client, login_user, mocker):
    mocker.patch('payment_services.create_stripe_checkout_session', return_value={
        'session_id': 'test_session',
        'checkout_url': 'https://checkout.stripe.com/test'
    })
    response = client.get('/product-checkout?product=academic_writing')
    assert response.status_code == 302
    assert 'https://checkout.stripe.com/test' in response.location
Performance:
Cache static data like assessment_products:
python

Copy
from flask_caching import Cache
cache = Cache(app, config={'CACHE_TYPE': 'redis'})
@cache.memoize(timeout=3600)
def get_assessment_products():
    return assessment_products
Security:
Add CSRF protection for POST routes (already enabled in app.py via CSRFProtect).
Validate session data integrity in payment success routes.
Summary of Key Action Items
Fix Undefined Variables:
Define country_code, country_name, assessment_preference, success_url, cancel_url, and stripe_publishable_key.
Enhance Security:
Require @login_required for /product-checkout.
Tighten CSP for Stripe scripts.
Validate session data in payment success routes.
Improve Error Handling:
Add robust validation for product_id.
Handle database and Stripe API errors in payment functions.
Integrate with AI Models:
Implement routes for submitting writing and speaking assessments, checking UserAssessmentAssignment.
Ensure AWS API calls are resilient with retry logic.
Centralize Configuration:
Move assessment_products to config.py.
Use environment variables for expiry periods and Stripe keys.
Add Logging and Testing:
Log all critical actions (e.g., profile access, checkout, payment).
Write tests for routes and payment processing.
By addressing these issues, the IELTSAIPrep application will provide a secure, reliable, and user-friendly experience for accessing TrueScore and ClearScore assessments. If you can share additional code (e.g., assessment_assignment_service, profile.html, or create_stripe_checkout_session), I can refine the review further.